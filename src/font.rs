use crate::pipeline::*;
use crate::sampler::*;
use crate::texture::*;
use serde::{Deserialize, Serialize};
use slender_math::*;
use std::collections::HashMap;
use std::io::{Read, Result};
use std::sync::Arc;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
enum AtlasType {
    #[serde(rename = "hardmask")]
    HardMask,
    #[serde(rename = "softmask")]
    SoftMask,
    #[serde(rename = "sdf")]
    Sdf,
    #[serde(rename = "psdf")]
    Psdf,
    #[serde(rename = "msdf")]
    Msdf,
    #[serde(rename = "mtsdf")]
    Mtsdf,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
enum YOrigin {
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top")]
    Top,
}

#[derive(Serialize, Deserialize)]
struct AtlasInfo {
    #[serde(rename = "type")]
    atlas_type: AtlasType,
    #[serde(rename = "distanceRange")]
    distance_range: f32,
    #[serde(rename = "size")]
    size: f32,
    #[serde(rename = "width")]
    width: u32,
    #[serde(rename = "height")]
    height: u32,
    #[serde(rename = "yOrigin")]
    y_origin: YOrigin,
}

#[derive(Serialize, Deserialize)]
struct FontMetrics {
    #[serde(rename = "emSize")]
    em_size: f32,
    #[serde(rename = "lineHeight")]
    line_height: f32,
    #[serde(rename = "ascender")]
    ascender: f32,
    #[serde(rename = "descender")]
    descender: f32,
    #[serde(rename = "underlineY")]
    underline_y: f32,
    #[serde(rename = "underlineThickness")]
    underline_thickness: f32,
}

#[derive(Serialize, Deserialize)]
struct Bounds {
    #[serde(rename = "left")]
    left: f32,
    #[serde(rename = "top")]
    top: f32,
    #[serde(rename = "right")]
    right: f32,
    #[serde(rename = "bottom")]
    bottom: f32,
}

#[derive(Serialize, Deserialize)]
struct Glyph {
    #[serde(rename = "unicode")]
    unicode: u32,
    #[serde(rename = "advance")]
    advance: f32,
    #[serde(rename = "planeBounds")]
    plane_bounds: Option<Bounds>,
    #[serde(rename = "atlasBounds")]
    atlas_bounds: Option<Bounds>,
}

#[derive(Serialize, Deserialize)]
struct Kerning {
    #[serde(rename = "unicode1")]
    unicode1: u32,
    #[serde(rename = "unicode2")]
    unicode2: u32,
    #[serde(rename = "advance")]
    advance: f32,
}

#[derive(Serialize, Deserialize)]
struct FontInfo {
    #[serde(rename = "atlas")]
    atlas: AtlasInfo,
    #[serde(rename = "metrics")]
    metrics: FontMetrics,
    #[serde(rename = "glyphs")]
    glyphs: Box<[Glyph]>,
    #[serde(rename = "kerning")]
    kerning: Box<[Kerning]>,
}

struct FontSprite {
    uv_top: f32,
    uv_bottom: f32,
    uv_left: f32,
    uv_right: f32,
    advance: f32,
    top: f32,
    bottom: f32,
    left: f32,
    right: f32,
}

enum FontGlyph {
    Advance(f32),
    Sprite(FontSprite),
}

impl FontGlyph {
    fn advance(&self) -> f32 {
        match self {
            &FontGlyph::Advance(advance) => advance,
            FontGlyph::Sprite(sprite) => sprite.advance,
        }
    }
}

/// A font atlas as generated by https://github.com/Chlumsky/msdf-atlas-gen
pub struct FontAtlas {
    atlas_type: AtlasType,
    line_height: f32,
    size: f32,
    range: f32,
    char_map: HashMap<char, FontGlyph>,
    kerning: HashMap<(char, char), f32>,
}

impl FontAtlas {
    pub fn load(reader: impl Read, texture_width: u32, texture_height: u32) -> Result<Self> {
        let info: FontInfo = serde_json::from_reader(reader)?;

        let atlas_type = info.atlas.atlas_type;
        let line_height = info.metrics.line_height / info.metrics.em_size;
        let base = (info.metrics.line_height - info.metrics.descender) / info.metrics.em_size;
        let size = info.atlas.size;
        let range = info.atlas.distance_range;
        assert_eq!(info.atlas.y_origin, YOrigin::Top);

        let mut char_map = HashMap::new();

        for glyph in info.glyphs.iter() {
            if let Some(c) = char::from_u32(glyph.unicode) {
                if let Some(atlas_bounds) = &glyph.atlas_bounds {
                    let plane_bounds = glyph.plane_bounds.as_ref().unwrap();

                    let uv_top = atlas_bounds.top / (texture_height as f32);
                    let uv_bottom = atlas_bounds.bottom / (texture_height as f32);
                    let uv_left = atlas_bounds.left / (texture_width as f32);
                    let uv_right = atlas_bounds.right / (texture_width as f32);

                    let advance = glyph.advance / info.metrics.em_size;

                    let top = (plane_bounds.top / info.metrics.em_size) + base;
                    let bottom = (plane_bounds.bottom / info.metrics.em_size) + base;
                    let left = plane_bounds.left / info.metrics.em_size;
                    let right = plane_bounds.right / info.metrics.em_size;

                    let sprite = FontSprite {
                        uv_top,
                        uv_bottom,
                        uv_left,
                        uv_right,
                        advance,
                        top,
                        bottom,
                        left,
                        right,
                    };

                    char_map.insert(c, FontGlyph::Sprite(sprite));
                } else {
                    let advance = glyph.advance / info.metrics.em_size;
                    char_map.insert(c, FontGlyph::Advance(advance));
                }
            }
        }

        let mut kerning = HashMap::new();
        for k in info.kerning.iter() {
            if let Some(lhs) = char::from_u32(k.unicode1) {
                if let Some(rhs) = char::from_u32(k.unicode2) {
                    kerning.insert((lhs, rhs), k.advance / info.metrics.em_size);
                }
            }
        }

        Ok(Self {
            atlas_type,
            line_height,
            size,
            range,
            char_map,
            kerning,
        })
    }

    fn get_kerning(&self, lhs: Option<char>, rhs: char) -> f32 {
        if let Some(lhs) = lhs {
            self.kerning.get(&(lhs, rhs)).copied().unwrap_or(0.0)
        } else {
            0.0
        }
    }
}

#[derive(Clone)]
pub struct Font {
    atlas: Arc<FontAtlas>,
    weight: f32,
    glyph_spacing: f32,
    stretch: f32,
}

#[allow(dead_code)]
impl Font {
    #[inline]
    pub fn new(atlas: Arc<FontAtlas>) -> Self {
        Self {
            atlas,
            weight: 0.0,
            glyph_spacing: 0.0,
            stretch: 1.0,
        }
    }

    #[inline]
    pub fn with_weight(mut self, weight: f32) -> Self {
        assert!(weight >= -1.0);
        assert!(weight <= 1.0);
        self.weight = weight;
        self
    }

    #[inline]
    pub fn with_glyph_spacing(mut self, glyph_spacing: f32) -> Self {
        self.glyph_spacing = glyph_spacing;
        self
    }

    #[inline]
    pub fn with_stretch(mut self, stretch: f32) -> Self {
        assert!(stretch > 0.0);
        self.stretch = stretch;
        self
    }
}

#[derive(Clone, Copy)]
pub struct GlyphVertex {
    pub position: v2f,
    pub tex_coord: v2f,
}

impl Default for GlyphVertex {
    #[inline]
    fn default() -> Self {
        Self {
            position: v2f::ZERO,
            tex_coord: v2f::ZERO,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SampleMode {
    Linear = 0,
    DistanceField = 1,
    MultiChannelDistanceField = 2,
}

impl From<AtlasType> for SampleMode {
    fn from(atlas_type: AtlasType) -> Self {
        match atlas_type {
            AtlasType::HardMask => Self::Linear,
            AtlasType::SoftMask => Self::Linear,
            AtlasType::Sdf => Self::DistanceField,
            AtlasType::Psdf => Self::DistanceField,
            AtlasType::Msdf => Self::MultiChannelDistanceField,
            AtlasType::Mtsdf => Self::MultiChannelDistanceField,
        }
    }
}

pub struct TextUniform<const CHANNELS: usize>
where
    Channels<CHANNELS>: ChannelDesc,
{
    pub view_proj: mat4,
    pub msdf: Arc<ColorTexture<Linear, CHANNELS>>,
    pub sampler: Sampler,
    pub color: v4f,
    pub origin: v2f,
    pub size: f32,
    pub width: f32,
    pub smoothing: f32,
    pub sample_mode: SampleMode,
    pub range: f32,
}

pub enum VS<const CHANNELS: usize> {}

impl VertexShader for VS<1> {
    type Input = GlyphVertex;
    type Output = v2f;
    type Uniform = TextUniform<1>;

    fn run(input: GlyphVertex, uniform: &TextUniform<1>) -> (v4f, v2f) {
        let pos = v4f::from_v2f(input.position * uniform.size + uniform.origin, 0.0, 1.0);
        (uniform.view_proj * pos, input.tex_coord)
    }
}

impl VertexShader for VS<4> {
    type Input = GlyphVertex;
    type Output = v2f;
    type Uniform = TextUniform<4>;

    fn run(input: GlyphVertex, uniform: &TextUniform<4>) -> (v4f, v2f) {
        let pos = v4f::from_v2f(input.position * uniform.size + uniform.origin, 0.0, 1.0);
        (uniform.view_proj * pos, input.tex_coord)
    }
}

fn median(v: v3f) -> f32 {
    let mut vals = v.to_array();
    if vals[0] > vals[1] {
        vals.swap(0, 1);
    }
    if vals[1] > vals[2] {
        vals.swap(1, 2);
    }
    if vals[0] > vals[1] {
        vals.swap(0, 1);
    }
    vals[1]
}

fn smoothstep(edge0: f32, edge1: f32, mut x: f32) -> f32 {
    if x <= edge0 {
        return 0.0;
    }

    if x >= edge1 {
        return 1.0;
    }

    x = (x - edge0) / (edge1 - edge0);
    x * x * (3.0 - 2.0 * x)
}

fn distance_field_color<const CHANNELS: usize>(uniform: &TextUniform<CHANNELS>, dist: f32) -> v4f
where
    Channels<CHANNELS>: ChannelDesc,
{
    let screen_dist = uniform.range * (dist + uniform.width - 0.5);
    let opacity = smoothstep(
        0.0 - (uniform.smoothing * 0.5),
        1.0 + (uniform.smoothing * 0.5),
        screen_dist,
    );

    let mut color = uniform.color;
    *color.a_mut() *= opacity;
    color
}

pub enum PS<const CHANNELS: usize> {}

impl PixelShader for PS<1> {
    type Input = v2f;
    type Output = v4f;
    type Uniform = TextUniform<1>;

    fn run(input: v2f, dx: v2f, dy: v2f, uniform: &TextUniform<1>) -> v4f {
        let texel = uniform.sampler.sample(&*uniform.msdf, input, dx, dy);

        match uniform.sample_mode {
            SampleMode::Linear => {
                let mut color = uniform.color;
                *color.a_mut() *= texel;
                color
            }
            SampleMode::DistanceField => distance_field_color(uniform, texel),
            SampleMode::MultiChannelDistanceField => unreachable!(),
        }
    }
}

impl PixelShader for PS<4> {
    type Input = v2f;
    type Output = v4f;
    type Uniform = TextUniform<4>;

    fn run(input: v2f, dx: v2f, dy: v2f, uniform: &TextUniform<4>) -> v4f {
        let texel = uniform.sampler.sample(&*uniform.msdf, input, dx, dy);

        match uniform.sample_mode {
            SampleMode::Linear => {
                let mut color = uniform.color;
                *color.a_mut() *= texel.r();
                color
            }
            SampleMode::DistanceField => {
                let dist = texel.r();
                distance_field_color(uniform, dist)
            }
            SampleMode::MultiChannelDistanceField => {
                let dist = median(texel.rgb());
                distance_field_color(uniform, dist)
            }
        }
    }
}

fn generate_indices(quad_count: usize) -> Box<[u16]> {
    let mut indices = Vec::with_capacity(6 * quad_count);

    let mut v = 0;
    for _ in 0..quad_count {
        indices.push(v + 0);
        indices.push(v + 1);
        indices.push(v + 2);
        indices.push(v + 0);
        indices.push(v + 2);
        indices.push(v + 3);

        v += 4;
    }

    indices.into_boxed_slice()
}

fn measure_word_width(
    mut text: impl Iterator<Item = char>,
    atlas: &FontAtlas,
    mut prev: char,
    glyph_spacing: f32,
) -> f32 {
    let mut width = 0.0;

    while let Some(c) = text.next() {
        if c.is_whitespace() {
            break;
        }

        if let Some(glyph) = atlas.char_map.get(&c) {
            let kerning = atlas.get_kerning(Some(prev), c);
            width += glyph.advance() + glyph_spacing + kerning;
        }
        prev = c;
    }

    width
}

const QUAD_CACHE_SIZE: usize = 8192;

pub struct TextRenderer<const CHANNELS: usize>
where
    Channels<CHANNELS>: ChannelDesc,
    VS<CHANNELS>: VertexShader<Input = GlyphVertex, Output = v2f, Uniform = TextUniform<CHANNELS>>,
    PS<CHANNELS>: PixelShader<Input = v2f, Output = v4f, Uniform = TextUniform<CHANNELS>>,
{
    pipeline: Pipeline<VS<CHANNELS>, PS<CHANNELS>>,
    vertices: Box<[GlyphVertex]>,
    indices: Box<[u16]>,
    sampler: Sampler,
}

impl<const CHANNELS: usize> TextRenderer<CHANNELS>
where
    Channels<CHANNELS>: ChannelDesc,
    VS<CHANNELS>: VertexShader<Input = GlyphVertex, Output = v2f, Uniform = TextUniform<CHANNELS>>,
    PS<CHANNELS>: PixelShader<Input = v2f, Output = v4f, Uniform = TextUniform<CHANNELS>>,
{
    pub fn new() -> Self {
        let pipeline = Pipeline::new(BlendMode::AlphaBlend, FrontFace::None);
        let vertices = vec![GlyphVertex::default(); 4 * QUAD_CACHE_SIZE].into_boxed_slice();
        let indices = generate_indices(QUAD_CACHE_SIZE);
        let sampler = Sampler {
            min_filter: TextureFilter::Linear,
            mag_filter: TextureFilter::Linear,
            mip_filter: TextureFilter::Nearest,
            wrap_x: TextureWrap::Clamp,
            wrap_y: TextureWrap::Clamp,
        };

        Self {
            pipeline,
            vertices,
            indices,
            sampler,
        }
    }

    fn add_quad(
        &mut self,
        top: f32,
        bottom: f32,
        left: f32,
        right: f32,
        tex_coord: &[v2f; 4],
        quad_count: &mut usize,
    ) {
        let index = 4 * *quad_count;

        self.vertices[index + 0] = GlyphVertex {
            position: v2f::new(left, top),
            tex_coord: tex_coord[0],
        };

        self.vertices[index + 1] = GlyphVertex {
            position: v2f::new(right, top),
            tex_coord: tex_coord[1],
        };

        self.vertices[index + 2] = GlyphVertex {
            position: v2f::new(right, bottom),
            tex_coord: tex_coord[2],
        };

        self.vertices[index + 3] = GlyphVertex {
            position: v2f::new(left, bottom),
            tex_coord: tex_coord[3],
        };

        *quad_count += 1;
    }

    pub fn draw_text<T: Texture<Texel = v4f>>(
        &mut self,
        color_buffer: &mut T,
        text: &str,
        msdf: Arc<ColorTexture<Linear, CHANNELS>>,
        font: &Font,
        font_size: f32,
        position: v2f,
        color: v4f,
        wrap_width: Option<f32>,
        smoothing: Option<f32>,
    ) {
        let atlas = &*font.atlas;
        let font_width = font.weight;
        let glyph_spacing = font.glyph_spacing;
        let stretch = font.stretch;
        let wrap_width = wrap_width.unwrap_or(f32::MAX);
        let smoothing = smoothing.unwrap_or(0.0);
        let sample_mode = atlas.atlas_type.into();

        assert!(font_size > 0.0);
        assert!(wrap_width > 0.0);
        assert!(smoothing >= 0.0);

        if CHANNELS < 3 {
            assert_ne!(sample_mode, SampleMode::MultiChannelDistanceField);
        }

        if text.trim_start().len() == 0 {
            return;
        }

        let view_proj = mat4::orthographic(
            0.0,
            color_buffer.width() as f32,
            color_buffer.height() as f32,
            0.0,
        );

        let font_width = font_width * 0.5;
        let range = (font_size / atlas.size) * atlas.range;
        let wrap_width = wrap_width / font_size;
        let glyph_spacing = glyph_spacing / font_size;

        let uniform = TextUniform {
            view_proj,
            msdf,
            sampler: self.sampler,

            color: srgb_to_linear(color),
            origin: position,
            size: font_size,
            width: font_width,
            smoothing,
            sample_mode,
            range,
        };

        let mut quad_count: usize = 0;
        let mut pos = v2f::ZERO;
        let mut prev: Option<char> = None;

        let mut chars = text.chars().peekable();
        'outer: loop {
            if let Some(c) = chars.next() {
                if c == '\n' {
                    *pos.x_mut() = 0.0;
                    *pos.y_mut() += atlas.line_height;
                    prev = None;
                } else if c.is_whitespace() {
                    if let Some(glyph) = atlas.char_map.get(&c) {
                        let kerning = atlas.get_kerning(prev, c);
                        *pos.x_mut() += (glyph.advance() + glyph_spacing + kerning) * stretch;
                        prev = Some(c);
                    }
                } else {
                    if let Some(prev_c) = prev {
                        let word_width =
                            measure_word_width(chars.clone(), atlas, prev_c, glyph_spacing)
                                * stretch;
                        if (pos.x() + word_width) >= wrap_width {
                            *pos.x_mut() = 0.0;
                            *pos.y_mut() += atlas.line_height;
                            prev = None;
                        }
                    }

                    let mut c = c;
                    'inner: loop {
                        if let Some(glyph) = atlas.char_map.get(&c) {
                            if (quad_count as usize) == QUAD_CACHE_SIZE {
                                self.pipeline.draw_indexed(
                                    color_buffer,
                                    None,
                                    &self.vertices,
                                    &self.indices,
                                    &uniform,
                                );

                                quad_count = 0;
                            }

                            let kerning = atlas.get_kerning(prev, c);

                            if let FontGlyph::Sprite(sprite) = &glyph {
                                let glyph_top = (pos.y() + sprite.top) * stretch;
                                let glyph_bottom = (pos.y() + sprite.bottom) * stretch;
                                let glyph_left = (pos.x() + sprite.left + kerning) * stretch;
                                let glyph_right = (pos.x() + sprite.right + kerning) * stretch;
                                let tex_coords = [
                                    v2f::new(sprite.uv_left, sprite.uv_top),
                                    v2f::new(sprite.uv_right, sprite.uv_top),
                                    v2f::new(sprite.uv_right, sprite.uv_bottom),
                                    v2f::new(sprite.uv_left, sprite.uv_bottom),
                                ];

                                self.add_quad(
                                    glyph_top,
                                    glyph_bottom,
                                    glyph_left,
                                    glyph_right,
                                    &tex_coords,
                                    &mut quad_count,
                                );
                            }

                            *pos.x_mut() += (glyph.advance() + glyph_spacing + kerning) * stretch;
                            prev = Some(c);
                        }

                        if let Some(next_c) = chars.peek() {
                            if next_c.is_whitespace() {
                                break 'inner;
                            } else {
                                c = chars.next().unwrap();
                            }
                        } else {
                            break 'outer;
                        }
                    }
                }
            } else {
                break 'outer;
            }
        }

        if quad_count > 0 {
            self.pipeline.draw_indexed(
                color_buffer,
                None,
                &self.vertices,
                &self.indices[0..(6 * quad_count)],
                &uniform,
            );
        }
    }
}
